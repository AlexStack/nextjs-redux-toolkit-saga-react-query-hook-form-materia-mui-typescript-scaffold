{"type_of":"article","id":1244852,"title":"An animated guide for Node.js event loop","description":"We have all heard about JavaScript and Node.js being single-threaded, but what does it mean in...","readable_publish_date":"Nov 5","slug":"an-animated-guide-to-nodejs-event-loop-3g62","path":"/nodedoctors/an-animated-guide-to-nodejs-event-loop-3g62","url":"https://dev.to/nodedoctors/an-animated-guide-to-nodejs-event-loop-3g62","comments_count":22,"public_reactions_count":615,"collection_id":null,"published_timestamp":"2022-11-05T18:15:13Z","positive_reactions_count":615,"cover_image":"https://res.cloudinary.com/practicaldev/image/fetch/s--5P6_6Rig--/c_imagga_scale,f_auto,fl_progressive,h_420,q_66,w_1000/https://dev-to-uploads.s3.amazonaws.com/uploads/articles/k2l36khs41oncfwmy3wk.gif","social_image":"https://res.cloudinary.com/practicaldev/image/fetch/s--4U9iPU-P--/c_imagga_scale,f_auto,fl_progressive,h_500,q_66,w_1000/https://dev-to-uploads.s3.amazonaws.com/uploads/articles/k2l36khs41oncfwmy3wk.gif","canonical_url":"https://dev.to/nodedoctors/an-animated-guide-to-nodejs-event-loop-3g62","created_at":"2022-11-05T18:15:14Z","edited_at":"2022-11-05T20:12:48Z","crossposted_at":null,"published_at":"2022-11-05T18:15:13Z","last_comment_at":"2022-11-07T21:42:37Z","reading_time_minutes":3,"tag_list":"javascript, node, beginners, webdev","tags":["javascript","node","beginners","webdev"],"body_html":"<p>We have all heard about JavaScript and Node.js being single-threaded, but what does it mean in practical terms?</p>\n\n<p>It means that JavaScript can do one thing at a time. For example, we cannot simultaneously multiply and sum numbers. We usually do operations in sequence. We add and then multiply or vice versa. Modern computers are fast, and the result of two or more consecutive tasks seems to be computed simultaneously, but there are exceptions.</p>\n\n<p>We all have tried to scrape data from that slow website or waited more than thirty seconds before getting the result of a database query. Do we want to block our single thread from executing more tasks because of a slow database query? Luckily, Node.js doesn’t stop from running other operations because of Libuv, a C++ library responsible for the event loop and asynchronously handling tasks such as network requests, DNS resolution, file system operations, data encryption, etc.</p>\n\n<p>What happens under the hood when Node.js works on tasks such as database queries? We will explore it by following this piece of code step by step.</p>\n\n<p><a href=\"https://res.cloudinary.com/practicaldev/image/fetch/s--_RAmRR48--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://dev-to-uploads.s3.amazonaws.com/uploads/articles/j7r4s8bxdbv73bv93vit.png\" class=\"article-body-image-wrapper\"><img src=\"https://res.cloudinary.com/practicaldev/image/fetch/s--_RAmRR48--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://dev-to-uploads.s3.amazonaws.com/uploads/articles/j7r4s8bxdbv73bv93vit.png\" alt=\"Code sample to showcase the event loop\" loading=\"lazy\" width=\"880\" height=\"389\"></a></p>\n\n<p>The V8 JavaScript engine manages a call stack, an essential piece that tracks which part of our program is running. Whenever we invoke a JavaScript function, it gets pushed to the call stack. Once the function reaches its end or a <code>return</code> statement, it is popped off the stack.</p>\n\n<p>In our example, the line of code <code>console.log('Starting Node.js')</code> is added to the call stack and prints <code>Starting Node.js</code> to the console. By doing so, it reaches the end of the <code>log</code> function and is removed from the call stack.</p>\n\n<p><a href=\"https://res.cloudinary.com/practicaldev/image/fetch/s--XIICQ_e4--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_66%2Cw_880/https://dev-to-uploads.s3.amazonaws.com/uploads/articles/m2ja8tymo646or3emo07.gif\" class=\"article-body-image-wrapper\"><img src=\"https://res.cloudinary.com/practicaldev/image/fetch/s--XIICQ_e4--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_66%2Cw_880/https://dev-to-uploads.s3.amazonaws.com/uploads/articles/m2ja8tymo646or3emo07.gif\" alt=\"Function invocation on Node.js call stack\" loading=\"lazy\" width=\"880\" height=\"495\" data-animated=\"true\"></a></p>\n\n<p>The following line of code is a database query. These tasks are immediately popped off because they may take a long time. They are passed to Libuv, which asynchronously handles them in the background. At the same time, Node.js can keep running other code without blocking its single thread.</p>\n\n<p>In the future, Node.js will know what to do with the query because we have associated a callback function with instructions to handle the task result or error. In our case, it is a simple <code>console.log</code>, but it could be complex business logic or data processing in production applications.</p>\n\n<p><a href=\"https://res.cloudinary.com/practicaldev/image/fetch/s--7VqJsN97--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_66%2Cw_880/https://dev-to-uploads.s3.amazonaws.com/uploads/articles/l2vxqbfq6r7e55up4bnz.gif\" class=\"article-body-image-wrapper\"><img src=\"https://res.cloudinary.com/practicaldev/image/fetch/s--7VqJsN97--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_66%2Cw_880/https://dev-to-uploads.s3.amazonaws.com/uploads/articles/l2vxqbfq6r7e55up4bnz.gif\" alt=\"Libuv handles I/O ops\" loading=\"lazy\" width=\"880\" height=\"495\" data-animated=\"true\"></a></p>\n\n<p>While Libuv handles the query in the background, our JavaScript is not blocked and can continue with <code>console.log(”Before query result”)</code>.</p>\n\n<p><a href=\"https://res.cloudinary.com/practicaldev/image/fetch/s--u2guSyHC--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_66%2Cw_880/https://dev-to-uploads.s3.amazonaws.com/uploads/articles/5dnrdqoql3sp9rw0gt1x.gif\" class=\"article-body-image-wrapper\"><img src=\"https://res.cloudinary.com/practicaldev/image/fetch/s--u2guSyHC--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_66%2Cw_880/https://dev-to-uploads.s3.amazonaws.com/uploads/articles/5dnrdqoql3sp9rw0gt1x.gif\" alt=\"Processing I/O while Node.js runs our code\" loading=\"lazy\" width=\"880\" height=\"495\" data-animated=\"true\"></a></p>\n\n<p>When the query is done, its callback is pushed to the I/O Event Queue to be run shortly*<em>.</em>* The event loop connects the queue with the call stack. It checks if the latter is empty and moves the first queue item for execution.</p>\n\n<p><a href=\"https://res.cloudinary.com/practicaldev/image/fetch/s--Dg8fq92f--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_66%2Cw_880/https://dev-to-uploads.s3.amazonaws.com/uploads/articles/pp9n3grfwgcaqgi30t4e.gif\" class=\"article-body-image-wrapper\"><img src=\"https://res.cloudinary.com/practicaldev/image/fetch/s--Dg8fq92f--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_66%2Cw_880/https://dev-to-uploads.s3.amazonaws.com/uploads/articles/pp9n3grfwgcaqgi30t4e.gif\" alt=\"The event loop checks for an empty call stack\" loading=\"lazy\" width=\"880\" height=\"495\" data-animated=\"true\"></a></p>\n\n<p>The code is available at <a href=\"https://github.com/fabrilallo/event-loop-1\">https://github.com/fabrilallo/event-loop-1</a></p>\n\n<h2>\n  <a name=\"pop-quiz-on-the-event-loop\" href=\"#pop-quiz-on-the-event-loop\">\n  </a>\n  Pop quiz on the event loop\n</h2>\n\n<p>Try to figure out what the following code prints on the console.</p>\n\n<p><a href=\"https://res.cloudinary.com/practicaldev/image/fetch/s--pDutR0RR--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://dev-to-uploads.s3.amazonaws.com/uploads/articles/lu4v4a7ryrp347glwrf1.png\" class=\"article-body-image-wrapper\"><img src=\"https://res.cloudinary.com/practicaldev/image/fetch/s--pDutR0RR--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://dev-to-uploads.s3.amazonaws.com/uploads/articles/lu4v4a7ryrp347glwrf1.png\" alt=\"A more complicated code sample to showcase the event loop\" loading=\"lazy\" width=\"880\" height=\"436\"></a></p>\n\n<p><a href=\"https://res.cloudinary.com/practicaldev/image/fetch/s--Skd-Oc4e--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://imgur.com/1sV8nGA\" class=\"article-body-image-wrapper\"><img src=\"https://res.cloudinary.com/practicaldev/image/fetch/s--Skd-Oc4e--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://imgur.com/1sV8nGA\" alt=\"An animated guide for the event loop\" loading=\"lazy\" width=\"\" height=\"\"></a></p>\n\n<h2>\n  <a name=\"conclusion\" href=\"#conclusion\">\n  </a>\n  Conclusion\n</h2>\n\n<p>The event loop, the delegation, and the asynchronous processing mechanism are Node.js's secret ingredients to process thousands of connections, read/write gigantic files, handling timers while working on other parts of our code.</p>\n\n<p>In the article, we saw the vital role of Libuv and its ability to handle numerous potentially long-running tasks. At the same time, we went through the event loop and its role as a bridge/connector between callbacks of asynchronous operations in the I/O event queue and the call stack. In the following articles, we will explore in greater detail how <strong>timers</strong>, <strong>I/O</strong>, <strong>promises</strong>, and <strong>ticks</strong> are handled by the different phases of the event loop.</p>\n\n<p>If you liked the article, follow us on Twitter <a class=\"mentioned-user\" href=\"https://dev.to/fabriziolallo\">@fabriziolallo</a>  and <a class=\"mentioned-user\" href=\"https://dev.to/andrewhu368\">@andrewhu368</a></p>\n\n","body_markdown":"We have all heard about JavaScript and Node.js being single-threaded, but what does it mean in practical terms?\n\nIt means that JavaScript can do one thing at a time. For example, we cannot simultaneously multiply and sum numbers. We usually do operations in sequence. We add and then multiply or vice versa. Modern computers are fast, and the result of two or more consecutive tasks seems to be computed simultaneously, but there are exceptions.\n\nWe all have tried to scrape data from that slow website or waited more than thirty seconds before getting the result of a database query. Do we want to block our single thread from executing more tasks because of a slow database query? Luckily, Node.js doesn’t stop from running other operations because of Libuv, a C++ library responsible for the event loop and asynchronously handling tasks such as network requests, DNS resolution, file system operations, data encryption, etc.\n\nWhat happens under the hood when Node.js works on tasks such as database queries? We will explore it by following this piece of code step by step.\n\n![Code sample to showcase the event loop](https://dev-to-uploads.s3.amazonaws.com/uploads/articles/j7r4s8bxdbv73bv93vit.png)\n\n\nThe V8 JavaScript engine manages a call stack, an essential piece that tracks which part of our program is running. Whenever we invoke a JavaScript function, it gets pushed to the call stack. Once the function reaches its end or a `return` statement, it is popped off the stack.\n\nIn our example, the line of code `console.log('Starting Node.js')` is added to the call stack and prints `Starting Node.js` to the console. By doing so, it reaches the end of the `log` function and is removed from the call stack.\n\n![Function invocation on Node.js call stack](https://dev-to-uploads.s3.amazonaws.com/uploads/articles/m2ja8tymo646or3emo07.gif)\n\n\nThe following line of code is a database query. These tasks are immediately popped off because they may take a long time. They are passed to Libuv, which asynchronously handles them in the background. At the same time, Node.js can keep running other code without blocking its single thread.\n\nIn the future, Node.js will know what to do with the query because we have associated a callback function with instructions to handle the task result or error. In our case, it is a simple `console.log`, but it could be complex business logic or data processing in production applications.\n\n![Libuv handles I/O ops](https://dev-to-uploads.s3.amazonaws.com/uploads/articles/l2vxqbfq6r7e55up4bnz.gif)\n\nWhile Libuv handles the query in the background, our JavaScript is not blocked and can continue with `console.log(”Before query result”)`.\n\n![Processing I/O while Node.js runs our code](https://dev-to-uploads.s3.amazonaws.com/uploads/articles/5dnrdqoql3sp9rw0gt1x.gif)\n\nWhen the query is done, its callback is pushed to the I/O Event Queue to be run shortly**.** The event loop connects the queue with the call stack. It checks if the latter is empty and moves the first queue item for execution.\n\n![The event loop checks for an empty call stack](https://dev-to-uploads.s3.amazonaws.com/uploads/articles/pp9n3grfwgcaqgi30t4e.gif)\n\nThe code is available at https://github.com/fabrilallo/event-loop-1\n\n## Pop quiz on the event loop\n\nTry to figure out what the following code prints on the console.\n\n![A more complicated code sample to showcase the event loop](https://dev-to-uploads.s3.amazonaws.com/uploads/articles/lu4v4a7ryrp347glwrf1.png)\n\n![An animated guide for the event loop](https://imgur.com/1sV8nGA)\n\n## Conclusion\n\nThe event loop, the delegation, and the asynchronous processing mechanism are Node.js's secret ingredients to process thousands of connections, read/write gigantic files, handling timers while working on other parts of our code.\n\nIn the article, we saw the vital role of Libuv and its ability to handle numerous potentially long-running tasks. At the same time, we went through the event loop and its role as a bridge/connector between callbacks of asynchronous operations in the I/O event queue and the call stack. In the following articles, we will explore in greater detail how **timers**, **I/O**, **promises**, and **ticks** are handled by the different phases of the event loop.\n\nIf you liked the article, follow us on Twitter @fabriziolallo  and @AndrewHu368","user":{"name":"Andrew Hu","username":"andrewhu368","twitter_username":"AndrewHu368","github_username":"andrew-hu368","user_id":937608,"website_url":"https://andrewhu.dev","profile_image":"https://res.cloudinary.com/practicaldev/image/fetch/s--ircVVt4a--/c_fill,f_auto,fl_progressive,h_640,q_auto,w_640/https://dev-to-uploads.s3.amazonaws.com/uploads/user/profile_image/937608/3d3508db-b29d-49e8-bcab-51764a170b54.jpeg","profile_image_90":"https://res.cloudinary.com/practicaldev/image/fetch/s--OhXtfyIK--/c_fill,f_auto,fl_progressive,h_90,q_auto,w_90/https://dev-to-uploads.s3.amazonaws.com/uploads/user/profile_image/937608/3d3508db-b29d-49e8-bcab-51764a170b54.jpeg"},"organization":{"name":"Node Doctors","username":"nodedoctors","slug":"nodedoctors","profile_image":"https://res.cloudinary.com/practicaldev/image/fetch/s--HmDAnBON--/c_fill,f_auto,fl_progressive,h_640,q_auto,w_640/https://dev-to-uploads.s3.amazonaws.com/uploads/organization/profile_image/6231/5e783a27-0c27-4025-9921-d30181489b57.png","profile_image_90":"https://res.cloudinary.com/practicaldev/image/fetch/s--AG4BpXYb--/c_fill,f_auto,fl_progressive,h_90,q_auto,w_90/https://dev-to-uploads.s3.amazonaws.com/uploads/organization/profile_image/6231/5e783a27-0c27-4025-9921-d30181489b57.png"}}